;; Analyzed by ClojureScript 1.7.145
{:use-macros {mlet cats.core}, :excludes #{when unless filter sequence}, :name cats.core, :imports nil, :requires {p cats.protocols, cats.protocols cats.protocols, clojure.set clojure.set, ctx cats.context, cats.context cats.context}, :uses nil, :defs {arity {:protocol-inline nil, :meta {:file "/home/emh/github/glsl-graph/resources/public/js/compiled/out/cats/core.cljc", :line 432, :column 8, :end-line 432, :end-column 13, :private true, :arglists (quote ([var]))}, :private true, :name cats.core/arity, :variadic false, :file "resources/public/js/compiled/out/cats/core.cljc", :end-column 13, :method-params ([var]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 432, :end-line 432, :max-fixed-arity 1, :fn-var true, :arglists (quote ([var]))}, pure {:protocol-inline nil, :meta {:file "/home/emh/github/glsl-graph/resources/public/js/compiled/out/cats/core.cljc", :line 54, :column 7, :end-line 54, :end-column 11, :arglists (quote ([v] [ctx v])), :doc "Given any value `v`, return it wrapped in\n  the default/effect-free context.\n\n  This is a multi-arity function that with arity `pure/1`\n  uses the dynamic scope to resolve the current\n  context. With `pure/2`, you can force a specific context\n  value.\n\n  Example:\n\n      (with-context either/context\n        (pure 1))\n      ;; => #<Right [1]>\n\n      (pure either/context 1)\n      ;; => #<Right [1]>\n  ", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([v] [ctx v]), :arglists ([v] [ctx v]), :arglists-meta (nil nil)}}, :name cats.core/pure, :variadic false, :file "resources/public/js/compiled/out/cats/core.cljc", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([v] [ctx v]), :arglists ([v] [ctx v]), :arglists-meta (nil nil)}, :method-params ([v] [ctx v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 54, :end-line 54, :max-fixed-arity 2, :fn-var true, :arglists ([v] [ctx v]), :doc "Given any value `v`, return it wrapped in\n  the default/effect-free context.\n\n  This is a multi-arity function that with arity `pure/1`\n  uses the dynamic scope to resolve the current\n  context. With `pure/2`, you can force a specific context\n  value.\n\n  Example:\n\n      (with-context either/context\n        (pure 1))\n      ;; => #<Right [1]>\n\n      (pure either/context 1)\n      ;; => #<Right [1]>\n  "}, arglists {:protocol-inline nil, :meta {:file "/home/emh/github/glsl-graph/resources/public/js/compiled/out/cats/core.cljc", :line 422, :column 8, :end-line 422, :end-column 16, :private true, :arglists (quote ([var]))}, :private true, :name cats.core/arglists, :variadic false, :file "resources/public/js/compiled/out/cats/core.cljc", :end-column 16, :method-params ([var]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 422, :end-line 422, :max-fixed-arity 1, :fn-var true, :arglists (quote ([var]))}, foldl {:protocol-inline nil, :meta {:file "/home/emh/github/glsl-graph/resources/public/js/compiled/out/cats/core.cljc", :line 693, :column 7, :end-line 693, :end-column 12, :arglists (quote ([f z xs])), :doc "Perform a left-associative fold on the data structure."}, :name cats.core/foldl, :variadic false, :file "resources/public/js/compiled/out/cats/core.cljc", :end-column 12, :method-params ([f z xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 693, :end-line 693, :max-fixed-arity 3, :fn-var true, :arglists (quote ([f z xs])), :doc "Perform a left-associative fold on the data structure."}, fapply {:protocol-inline nil, :meta {:file "/home/emh/github/glsl-graph/resources/public/js/compiled/out/cats/core.cljc", :line 132, :column 7, :end-line 132, :end-column 13, :arglists (quote ([af & avs])), :doc "Given a function wrapped in a monadic context `af`,\n  and a value wrapped in a monadic context `av`,\n  apply the unwrapped function to the unwrapped value\n  and return the result, wrapped in the same context as `av`.\n\n  This function is variadic, so it can be used like\n  a Haskell-style left-associative fapply.", :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(af avs)], :arglists ([af & avs]), :arglists-meta (nil)}}, :name cats.core/fapply, :variadic true, :file "resources/public/js/compiled/out/cats/core.cljc", :end-column 13, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(af avs)], :arglists ([af & avs]), :arglists-meta (nil)}, :method-params [(af avs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 132, :end-line 132, :max-fixed-arity 1, :fn-var true, :arglists ([af & avs]), :doc "Given a function wrapped in a monadic context `af`,\n  and a value wrapped in a monadic context `av`,\n  apply the unwrapped function to the unwrapped value\n  and return the result, wrapped in the same context as `av`.\n\n  This function is variadic, so it can be used like\n  a Haskell-style left-associative fapply."}, <*> {:name cats.core/<*>, :file "resources/public/js/compiled/out/cats/core.cljc", :line 630, :column 1, :end-line 630, :end-column 9, :meta {:file "/home/emh/github/glsl-graph/resources/public/js/compiled/out/cats/core.cljc", :line 630, :column 6, :end-line 630, :end-column 9}, :doc "A Haskell-style `fapply` alias."}, guard {:protocol-inline nil, :meta {:file "/home/emh/github/glsl-graph/resources/public/js/compiled/out/cats/core.cljc", :line 110, :column 7, :end-line 110, :end-column 12, :arglists (quote ([b]))}, :name cats.core/guard, :variadic false, :file "resources/public/js/compiled/out/cats/core.cljc", :end-column 12, :method-params ([b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 110, :end-line 110, :max-fixed-arity 1, :fn-var true, :arglists (quote ([b]))}, join {:protocol-inline nil, :meta {:file "/home/emh/github/glsl-graph/resources/public/js/compiled/out/cats/core.cljc", :line 116, :column 7, :end-line 116, :end-column 11, :arglists (quote ([mv])), :doc "Remove one level of monadic structure.\n  This is the same as `(bind mv identity)`."}, :name cats.core/join, :variadic false, :file "resources/public/js/compiled/out/cats/core.cljc", :end-column 11, :method-params ([mv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 116, :end-line 116, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mv])), :doc "Remove one level of monadic structure.\n  This is the same as `(bind mv identity)`."}, bind {:protocol-inline nil, :meta {:file "/home/emh/github/glsl-graph/resources/public/js/compiled/out/cats/core.cljc", :line 81, :column 7, :end-line 81, :end-column 11, :arglists (quote ([mv f])), :doc "Given a monadic value `mv` and a function `f`,\n  apply `f` to the unwrapped value of `mv`.\n\n      (bind (either/right 1) (fn [v]\n                               (return (inc v))))\n      ;; => #<Right [2]>\n\n  For convenience, you may prefer to use the `mlet` macro,\n  which provides a beautiful, `let`-like syntax for\n  composing operations with the `bind` function."}, :name cats.core/bind, :variadic false, :file "resources/public/js/compiled/out/cats/core.cljc", :end-column 11, :method-params ([mv f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 81, :end-line 81, :max-fixed-arity 2, :fn-var true, :arglists (quote ([mv f])), :doc "Given a monadic value `mv` and a function `f`,\n  apply `f` to the unwrapped value of `mv`.\n\n      (bind (either/right 1) (fn [v]\n                               (return (inc v))))\n      ;; => #<Right [2]>\n\n  For convenience, you may prefer to use the `mlet` macro,\n  which provides a beautiful, `let`-like syntax for\n  composing operations with the `bind` function."}, deps {:protocol-inline nil, :meta {:file "/home/emh/github/glsl-graph/resources/public/js/compiled/out/cats/core.cljc", :line 217, :column 8, :end-line 217, :end-column 12, :private true, :arglists (quote ([expr syms]))}, :private true, :name cats.core/deps, :variadic false, :file "resources/public/js/compiled/out/cats/core.cljc", :end-column 12, :method-params ([expr syms]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 217, :end-line 217, :max-fixed-arity 2, :fn-var true, :arglists (quote ([expr syms]))}, topo-sort* {:protocol-inline nil, :meta {:file "/home/emh/github/glsl-graph/resources/public/js/compiled/out/cats/core.cljc", :line 299, :column 8, :end-line 299, :end-column 18, :private true, :arglists (quote ([deps seen batches current]))}, :private true, :name cats.core/topo-sort*, :variadic false, :file "resources/public/js/compiled/out/cats/core.cljc", :end-column 18, :method-params ([deps seen batches current]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 299, :end-line 299, :max-fixed-arity 4, :fn-var true, :arglists (quote ([deps seen batches current]))}, <$> {:name cats.core/<$>, :file "resources/public/js/compiled/out/cats/core.cljc", :line 626, :column 1, :end-line 626, :end-column 9, :meta {:file "/home/emh/github/glsl-graph/resources/public/js/compiled/out/cats/core.cljc", :line 626, :column 6, :end-line 626, :end-column 9}, :doc "A Haskell-style `fmap` alias."}, <=< {:protocol-inline nil, :meta {:file "/home/emh/github/glsl-graph/resources/public/js/compiled/out/cats/core.cljc", :line 669, :column 7, :end-line 669, :end-column 10, :arglists (quote ([mg mf x])), :doc "Right-to-left composition of monads.\n  Same as `>=>` with its first two arguments flipped."}, :name cats.core/<=<, :variadic false, :file "resources/public/js/compiled/out/cats/core.cljc", :end-column 10, :method-params ([mg mf x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 669, :end-line 669, :max-fixed-arity 3, :fn-var true, :arglists (quote ([mg mf x])), :doc "Right-to-left composition of monads.\n  Same as `>=>` with its first two arguments flipped."}, alet* {:protocol-inline nil, :meta {:file "/home/emh/github/glsl-graph/resources/public/js/compiled/out/cats/core.cljc", :line 329, :column 8, :end-line 329, :end-column 13, :private true, :arglists (quote ([batches env body]))}, :private true, :name cats.core/alet*, :variadic false, :file "resources/public/js/compiled/out/cats/core.cljc", :end-column 13, :method-params ([batches env body]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 329, :end-line 329, :max-fixed-arity 3, :fn-var true, :arglists (quote ([batches env body]))}, lift {:protocol-inline nil, :meta {:file "/home/emh/github/glsl-graph/resources/public/js/compiled/out/cats/core.cljc", :line 165, :column 7, :end-line 165, :end-column 11, :arglists (quote ([mv] [m mv])), :doc "Lift a value from the inner monad of a monad transformer\n  into a value of the monad transformer.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([mv] [m mv]), :arglists ([mv] [m mv]), :arglists-meta (nil nil)}}, :name cats.core/lift, :variadic false, :file "resources/public/js/compiled/out/cats/core.cljc", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([mv] [m mv]), :arglists ([mv] [m mv]), :arglists-meta (nil nil)}, :method-params ([mv] [m mv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 165, :end-line 165, :max-fixed-arity 2, :fn-var true, :arglists ([mv] [m mv]), :doc "Lift a value from the inner monad of a monad transformer\n  into a value of the monad transformer."}, single-arity? {:protocol-inline nil, :meta {:file "/home/emh/github/glsl-graph/resources/public/js/compiled/out/cats/core.cljc", :line 426, :column 8, :end-line 426, :end-column 21, :private true, :arglists (quote ([var]))}, :private true, :name cats.core/single-arity?, :variadic false, :file "resources/public/js/compiled/out/cats/core.cljc", :end-column 21, :method-params ([var]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 426, :end-line 426, :max-fixed-arity 1, :fn-var true, :arglists (quote ([var]))}, when {:protocol-inline nil, :meta {:file "/home/emh/github/glsl-graph/resources/public/js/compiled/out/cats/core.cljc", :line 145, :column 7, :end-line 145, :end-column 11, :arglists (quote ([b mv] [ctx b mv])), :doc "Given an expression and a monadic value,\n  if the expression is logical true, return the monadic value.\n  Otherwise, return nil in a monadic context.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([b mv] [ctx b mv]), :arglists ([b mv] [ctx b mv]), :arglists-meta (nil nil)}}, :name cats.core/when, :variadic false, :file "resources/public/js/compiled/out/cats/core.cljc", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([b mv] [ctx b mv]), :arglists ([b mv] [ctx b mv]), :arglists-meta (nil nil)}, :method-params ([b mv] [ctx b mv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 145, :end-line 145, :max-fixed-arity 3, :fn-var true, :arglists ([b mv] [ctx b mv]), :doc "Given an expression and a monadic value,\n  if the expression is logical true, return the monadic value.\n  Otherwise, return nil in a monadic context."}, >>= {:protocol-inline nil, :meta {:file "/home/emh/github/glsl-graph/resources/public/js/compiled/out/cats/core.cljc", :line 634, :column 7, :end-line 634, :end-column 10, :arglists (quote ([mv f] [mv f & fs])), :doc "Perform a Haskell-style left-associative bind.\n\n  Let's see it in action:\n\n      (>>= (just 1) (comp just inc) (comp just inc))\n      ;; => #<Just [3]>\n  ", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([mv f]), :arglists ([mv f] [mv f & fs]), :arglists-meta (nil nil)}}, :name cats.core/>>=, :variadic true, :file "resources/public/js/compiled/out/cats/core.cljc", :end-column 10, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([mv f]), :arglists ([mv f] [mv f & fs]), :arglists-meta (nil nil)}, :method-params ([mv f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 634, :end-line 634, :max-fixed-arity 2, :fn-var true, :arglists ([mv f] [mv f & fs]), :doc "Perform a Haskell-style left-associative bind.\n\n  Let's see it in action:\n\n      (>>= (just 1) (comp just inc) (comp just inc))\n      ;; => #<Just [3]>\n  "}, mzero {:protocol-inline nil, :meta {:file "/home/emh/github/glsl-graph/resources/public/js/compiled/out/cats/core.cljc", :line 98, :column 7, :end-line 98, :end-column 12, :arglists (quote ([] [ctx])), :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [ctx]), :arglists ([] [ctx]), :arglists-meta (nil nil)}}, :name cats.core/mzero, :variadic false, :file "resources/public/js/compiled/out/cats/core.cljc", :end-column 12, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [ctx]), :arglists ([] [ctx]), :arglists-meta (nil nil)}, :method-params ([] [ctx]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 98, :end-line 98, :max-fixed-arity 1, :fn-var true, :arglists ([] [ctx])}, return {:protocol-inline nil, :meta {:file "/home/emh/github/glsl-graph/resources/public/js/compiled/out/cats/core.cljc", :line 75, :column 7, :end-line 75, :end-column 13, :arglists (quote ([v] [ctx v])), :doc "This is a monad version of `pure` and works\n  identically to it.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([v] [ctx v]), :arglists ([v] [ctx v]), :arglists-meta (nil nil)}}, :name cats.core/return, :variadic false, :file "resources/public/js/compiled/out/cats/core.cljc", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([v] [ctx v]), :arglists ([v] [ctx v]), :arglists-meta (nil nil)}, :method-params ([v] [ctx v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 75, :end-line 75, :max-fixed-arity 2, :fn-var true, :arglists ([v] [ctx v]), :doc "This is a monad version of `pure` and works\n  identically to it."}, mappend {:protocol-inline nil, :meta {:file "/home/emh/github/glsl-graph/resources/public/js/compiled/out/cats/core.cljc", :line 48, :column 7, :end-line 48, :end-column 14, :arglists (quote ([& svs])), :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(svs)], :arglists ([& svs]), :arglists-meta (nil)}}, :name cats.core/mappend, :variadic true, :file "resources/public/js/compiled/out/cats/core.cljc", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(svs)], :arglists ([& svs]), :arglists-meta (nil)}, :method-params [(svs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 48, :end-line 48, :max-fixed-arity 0, :fn-var true, :arglists ([& svs])}, mapseq {:protocol-inline nil, :meta {:file "/home/emh/github/glsl-graph/resources/public/js/compiled/out/cats/core.cljc", :line 561, :column 7, :end-line 561, :end-column 13, :arglists (quote ([mf coll])), :doc "Given a function `mf` that takes a value and puts it into a\n  monadic context, and a collection, map `mf` over the collection,\n  calling `sequence` on the results.\n\n      (require '[cats.monad.maybe :as maybe])\n      (require '[cats.core :as m])\n\n      (m/mapseq maybe/just [2 3])\n      ;=> <Just [[2 3]]>\n\n      (m/mapseq (fn [v]\n                  (if (odd? v)\n                    (maybe/just v)\n                    (maybe/nothing)))\n                [1 2])\n      ;=> <Nothing>\n  "}, :name cats.core/mapseq, :variadic false, :file "resources/public/js/compiled/out/cats/core.cljc", :end-column 13, :method-params ([mf coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 561, :end-line 561, :max-fixed-arity 2, :fn-var true, :arglists (quote ([mf coll])), :doc "Given a function `mf` that takes a value and puts it into a\n  monadic context, and a collection, map `mf` over the collection,\n  calling `sequence` on the results.\n\n      (require '[cats.monad.maybe :as maybe])\n      (require '[cats.core :as m])\n\n      (m/mapseq maybe/just [2 3])\n      ;=> <Just [[2 3]]>\n\n      (m/mapseq (fn [v]\n                  (if (odd? v)\n                    (maybe/just v)\n                    (maybe/nothing)))\n                [1 2])\n      ;=> <Nothing>\n  "}, mplus {:protocol-inline nil, :meta {:file "/home/emh/github/glsl-graph/resources/public/js/compiled/out/cats/core.cljc", :line 104, :column 7, :end-line 104, :end-column 12, :arglists (quote ([& mvs])), :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(mvs)], :arglists ([& mvs]), :arglists-meta (nil)}}, :name cats.core/mplus, :variadic true, :file "resources/public/js/compiled/out/cats/core.cljc", :end-column 12, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(mvs)], :arglists ([& mvs]), :arglists-meta (nil)}, :method-params [(mvs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 104, :end-line 104, :max-fixed-arity 0, :fn-var true, :arglists ([& mvs])}, dedupe-symbols {:protocol-inline nil, :meta {:file "/home/emh/github/glsl-graph/resources/public/js/compiled/out/cats/core.cljc", :line 277, :column 8, :end-line 277, :end-column 22, :private true, :arglists (quote ([bindings body]))}, :private true, :name cats.core/dedupe-symbols, :variadic false, :file "resources/public/js/compiled/out/cats/core.cljc", :end-column 22, :method-params ([bindings body]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 277, :end-line 277, :max-fixed-arity 2, :fn-var true, :arglists (quote ([bindings body]))}, >> {:protocol-inline nil, :meta {:file "/home/emh/github/glsl-graph/resources/public/js/compiled/out/cats/core.cljc", :line 647, :column 7, :end-line 647, :end-column 9, :arglists (quote ([mv mv'] [mv mv' & mvs])), :doc "Perform a Haskell-style left-associative bind,\n  ignoring the values produced by the monadic computations.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([mv mv']), :arglists ([mv mv'] [mv mv' & mvs]), :arglists-meta (nil nil)}}, :name cats.core/>>, :variadic true, :file "resources/public/js/compiled/out/cats/core.cljc", :end-column 9, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([mv mv']), :arglists ([mv mv'] [mv mv' & mvs]), :arglists-meta (nil nil)}, :method-params ([mv mv']), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 647, :end-line 647, :max-fixed-arity 2, :fn-var true, :arglists ([mv mv'] [mv mv' & mvs]), :doc "Perform a Haskell-style left-associative bind,\n  ignoring the values produced by the monadic computations."}, rename {:protocol-inline nil, :meta {:file "/home/emh/github/glsl-graph/resources/public/js/compiled/out/cats/core.cljc", :line 234, :column 8, :end-line 234, :end-column 14, :private true, :arglists (quote ([expr renames]))}, :private true, :name cats.core/rename, :variadic false, :file "resources/public/js/compiled/out/cats/core.cljc", :end-column 14, :method-params ([expr renames]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 234, :end-line 234, :max-fixed-arity 2, :fn-var true, :arglists (quote ([expr renames]))}, rename-sym {:protocol-inline nil, :meta {:file "/home/emh/github/glsl-graph/resources/public/js/compiled/out/cats/core.cljc", :line 230, :column 8, :end-line 230, :end-column 18, :private true, :arglists (quote ([expr renames]))}, :private true, :name cats.core/rename-sym, :variadic false, :file "resources/public/js/compiled/out/cats/core.cljc", :end-column 18, :method-params ([expr renames]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 230, :end-line 230, :max-fixed-arity 2, :fn-var true, :arglists (quote ([expr renames]))}, unless {:protocol-inline nil, :meta {:file "/home/emh/github/glsl-graph/resources/public/js/compiled/out/cats/core.cljc", :line 156, :column 7, :end-line 156, :end-column 13, :arglists (quote ([b mv] [ctx b mv])), :doc "Given an expression and a monadic value,\n  if the expression is not logical true, return the monadic value.\n  Otherwise, return nil in a monadic context.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([b mv] [ctx b mv]), :arglists ([b mv] [ctx b mv]), :arglists-meta (nil nil)}}, :name cats.core/unless, :variadic false, :file "resources/public/js/compiled/out/cats/core.cljc", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([b mv] [ctx b mv]), :arglists ([b mv] [ctx b mv]), :arglists-meta (nil nil)}, :method-params ([b mv] [ctx b mv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 156, :end-line 156, :max-fixed-arity 3, :fn-var true, :arglists ([b mv] [ctx b mv]), :doc "Given an expression and a monadic value,\n  if the expression is not logical true, return the monadic value.\n  Otherwise, return nil in a monadic context."}, traverse {:protocol-inline nil, :meta {:file "/home/emh/github/glsl-graph/resources/public/js/compiled/out/cats/core.cljc", :line 742, :column 7, :end-line 742, :end-column 15, :arglists (quote ([f tv] [ctx f tv])), :doc "Map each element of a structure to an action, evaluate these\n  actions from left to right, and collect the results.\n\n      (defn inc-if-even\n        [n]\n        (if (even? n)\n          (maybe/just (inc n))\n          (maybe/nothing)))\n\n      (ctx/with-context maybe/context\n        (m/traverse inc-if-even [2 4]))\n      ;; => #<Just [3 4]>\n  ", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f tv] [ctx f tv]), :arglists ([f tv] [ctx f tv]), :arglists-meta (nil nil)}}, :name cats.core/traverse, :variadic false, :file "resources/public/js/compiled/out/cats/core.cljc", :end-column 15, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f tv] [ctx f tv]), :arglists ([f tv] [ctx f tv]), :arglists-meta (nil nil)}, :method-params ([f tv] [ctx f tv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 742, :end-line 742, :max-fixed-arity 3, :fn-var true, :arglists ([f tv] [ctx f tv]), :doc "Map each element of a structure to an action, evaluate these\n  actions from left to right, and collect the results.\n\n      (defn inc-if-even\n        [n]\n        (if (even? n)\n          (maybe/just (inc n))\n          (maybe/nothing)))\n\n      (ctx/with-context maybe/context\n        (m/traverse inc-if-even [2 4]))\n      ;; => #<Just [3 4]>\n  "}, forseq {:protocol-inline nil, :meta {:file "/home/emh/github/glsl-graph/resources/public/js/compiled/out/cats/core.cljc", :line 582, :column 7, :end-line 582, :end-column 13, :arglists (quote ([vs mf])), :doc "Same as `mapseq` but with the arguments flipped.\n\n  Let's see a little example:\n\n      (m/forseq [2 3] maybe/just)\n      ;; => <Just [[2 3]]>\n\n  Yet an other example that fails:\n\n      (m/forseq [1 2]\n                (fn [v]\n                  (if (odd? v)\n                    (maybe/just v)\n                    (maybe/nothing))))\n      ;; => <Nothing>\n  "}, :name cats.core/forseq, :variadic false, :file "resources/public/js/compiled/out/cats/core.cljc", :end-column 13, :method-params ([vs mf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 582, :end-line 582, :max-fixed-arity 2, :fn-var true, :arglists (quote ([vs mf])), :doc "Same as `mapseq` but with the arguments flipped.\n\n  Let's see a little example:\n\n      (m/forseq [2 3] maybe/just)\n      ;; => <Just [[2 3]]>\n\n  Yet an other example that fails:\n\n      (m/forseq [1 2]\n                (fn [v]\n                  (if (odd? v)\n                    (maybe/just v)\n                    (maybe/nothing))))\n      ;; => <Nothing>\n  "}, =<< {:protocol-inline nil, :meta {:file "/home/emh/github/glsl-graph/resources/public/js/compiled/out/cats/core.cljc", :line 655, :column 7, :end-line 655, :end-column 10, :arglists (quote ([f mv])), :doc "Same as the two argument version of `>>=` but with the\n  arguments flipped."}, :name cats.core/=<<, :variadic false, :file "resources/public/js/compiled/out/cats/core.cljc", :end-column 10, :method-params ([f mv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 655, :end-line 655, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f mv])), :doc "Same as the two argument version of `>>=` but with the\n  arguments flipped."}, foldr {:protocol-inline nil, :meta {:file "/home/emh/github/glsl-graph/resources/public/js/compiled/out/cats/core.cljc", :line 686, :column 7, :end-line 686, :end-column 12, :arglists (quote ([f z xs])), :doc "Perform a right-associative fold on the data structure."}, :name cats.core/foldr, :variadic false, :file "resources/public/js/compiled/out/cats/core.cljc", :end-column 12, :method-params ([f z xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 686, :end-line 686, :max-fixed-arity 3, :fn-var true, :arglists (quote ([f z xs])), :doc "Perform a right-associative fold on the data structure."}, >=> {:protocol-inline nil, :meta {:file "/home/emh/github/glsl-graph/resources/public/js/compiled/out/cats/core.cljc", :line 661, :column 7, :end-line 661, :end-column 10, :arglists (quote ([mf mg x])), :doc "Left-to-right composition of monads."}, :name cats.core/>=>, :variadic false, :file "resources/public/js/compiled/out/cats/core.cljc", :end-column 10, :method-params ([mf mg x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 661, :end-line 661, :max-fixed-arity 3, :fn-var true, :arglists (quote ([mf mg x])), :doc "Left-to-right composition of monads."}, dependency-map {:protocol-inline nil, :meta {:file "/home/emh/github/glsl-graph/resources/public/js/compiled/out/cats/core.cljc", :line 284, :column 8, :end-line 284, :end-column 22, :private true, :arglists (quote ([sym->ap]))}, :private true, :name cats.core/dependency-map, :variadic false, :file "resources/public/js/compiled/out/cats/core.cljc", :end-column 22, :method-params ([sym->ap]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 284, :end-line 284, :max-fixed-arity 1, :fn-var true, :arglists (quote ([sym->ap]))}, <> {:name cats.core/<>, :file "resources/public/js/compiled/out/cats/core.cljc", :line 684, :column 1, :end-line 684, :end-column 8, :meta {:file "/home/emh/github/glsl-graph/resources/public/js/compiled/out/cats/core.cljc", :line 684, :column 6, :end-line 684, :end-column 8}}, topo-sort {:protocol-inline nil, :meta {:file "/home/emh/github/glsl-graph/resources/public/js/compiled/out/cats/core.cljc", :line 316, :column 8, :end-line 316, :end-column 17, :private true, :arglists (quote ([deps]))}, :private true, :name cats.core/topo-sort, :variadic false, :file "resources/public/js/compiled/out/cats/core.cljc", :end-column 17, :method-params ([deps]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 316, :end-line 316, :max-fixed-arity 1, :fn-var true, :arglists (quote ([deps]))}, filter {:protocol-inline nil, :meta {:file "/home/emh/github/glsl-graph/resources/public/js/compiled/out/cats/core.cljc", :line 602, :column 7, :end-line 602, :end-column 13, :arglists (quote ([p mv])), :doc "Apply a predicate to a value in a `MonadZero` instance,\n  returning the identity element when the predicate does not hold.\n\n  Otherwise, return the instance unchanged.\n\n      (require '[cats.monad.maybe :as maybe])\n      (require '[cats.core :as m])\n\n      (m/filter (partial < 2) (maybe/just 3))\n      ;=> <Just [3]>\n\n      (m/filter (partial < 4) (maybe/just 3))\n      ;=> <Nothing>\n  "}, :name cats.core/filter, :variadic false, :file "resources/public/js/compiled/out/cats/core.cljc", :end-column 13, :method-params ([p mv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 602, :end-line 602, :max-fixed-arity 2, :fn-var true, :arglists (quote ([p mv])), :doc "Apply a predicate to a value in a `MonadZero` instance,\n  returning the identity element when the predicate does not hold.\n\n  Otherwise, return the instance unchanged.\n\n      (require '[cats.monad.maybe :as maybe])\n      (require '[cats.core :as m])\n\n      (m/filter (partial < 2) (maybe/just 3))\n      ;=> <Just [3]>\n\n      (m/filter (partial < 4) (maybe/just 3))\n      ;=> <Nothing>\n  "}, dedupe-symbols* {:protocol-inline nil, :meta {:file "/home/emh/github/glsl-graph/resources/public/js/compiled/out/cats/core.cljc", :line 244, :column 8, :end-line 244, :end-column 23, :private true, :arglists (quote ([sym->ap body]))}, :private true, :name cats.core/dedupe-symbols*, :variadic false, :file "resources/public/js/compiled/out/cats/core.cljc", :end-column 23, :method-params ([sym->ap body]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 244, :end-line 244, :max-fixed-arity 2, :fn-var true, :arglists (quote ([sym->ap body]))}, fmap {:protocol-inline nil, :meta {:file "/home/emh/github/glsl-graph/resources/public/js/compiled/out/cats/core.cljc", :line 122, :column 7, :end-line 122, :end-column 11, :arglists (quote ([f] [f fv])), :doc "Apply a function `f` to the value wrapped in functor `fv`,\n  preserving the context type.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f fv]), :arglists ([f] [f fv]), :arglists-meta (nil nil)}}, :name cats.core/fmap, :variadic false, :file "resources/public/js/compiled/out/cats/core.cljc", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f fv]), :arglists ([f] [f fv]), :arglists-meta (nil nil)}, :method-params ([f] [f fv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 122, :end-line 122, :max-fixed-arity 2, :fn-var true, :arglists ([f] [f fv]), :doc "Apply a function `f` to the value wrapped in functor `fv`,\n  preserving the context type."}, mempty {:protocol-inline nil, :meta {:file "/home/emh/github/glsl-graph/resources/public/js/compiled/out/cats/core.cljc", :line 44, :column 7, :end-line 44, :end-column 13, :arglists (quote ([] [ctx])), :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [ctx]), :arglists ([] [ctx]), :arglists-meta (nil nil)}}, :name cats.core/mempty, :variadic false, :file "resources/public/js/compiled/out/cats/core.cljc", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [ctx]), :arglists ([] [ctx]), :arglists-meta (nil nil)}, :method-params ([] [ctx]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 44, :end-line 44, :max-fixed-arity 1, :fn-var true, :arglists ([] [ctx])}, remove-deps {:protocol-inline nil, :meta {:file "/home/emh/github/glsl-graph/resources/public/js/compiled/out/cats/core.cljc", :line 293, :column 8, :end-line 293, :end-column 19, :private true, :arglists (quote ([deps symset]))}, :private true, :name cats.core/remove-deps, :variadic false, :file "resources/public/js/compiled/out/cats/core.cljc", :end-column 19, :method-params ([deps symset]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 293, :end-line 293, :max-fixed-arity 2, :fn-var true, :arglists (quote ([deps symset]))}, extract {:protocol-inline nil, :meta {:file "/home/emh/github/glsl-graph/resources/public/js/compiled/out/cats/core.cljc", :line 678, :column 7, :end-line 678, :end-column 14, :arglists (quote ([v])), :doc "Generic function to unwrap/extract\n  the inner value of a container."}, :name cats.core/extract, :variadic false, :file "resources/public/js/compiled/out/cats/core.cljc", :end-column 14, :method-params ([v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 678, :end-line 678, :max-fixed-arity 1, :fn-var true, :arglists (quote ([v])), :doc "Generic function to unwrap/extract\n  the inner value of a container."}, sequence {:protocol-inline nil, :meta {:file "/home/emh/github/glsl-graph/resources/public/js/compiled/out/cats/core.cljc", :line 540, :column 7, :end-line 540, :end-column 15, :arglists (quote ([mvs])), :doc "Given a non-empty collection of monadic values, collect\n  their values in a vector returned in the monadic context.\n\n      (sequence [(maybe/just 2) (maybe/just 3)])\n      ;; => <Just [[2, 3]]>\n\n      (sequence [(maybe/nothing) (maybe/just 3)])\n      ;; => <Nothing>\n  "}, :name cats.core/sequence, :variadic false, :file "resources/public/js/compiled/out/cats/core.cljc", :end-column 15, :method-params ([mvs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 540, :end-line 540, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mvs])), :doc "Given a non-empty collection of monadic values, collect\n  their values in a vector returned in the monadic context.\n\n      (sequence [(maybe/just 2) (maybe/just 3)])\n      ;; => <Just [[2, 3]]>\n\n      (sequence [(maybe/nothing) (maybe/just 3)])\n      ;; => <Nothing>\n  "}, foldm {:protocol-inline nil, :meta {:file "/home/emh/github/glsl-graph/resources/public/js/compiled/out/cats/core.cljc", :line 700, :column 7, :end-line 700, :end-column 12, :arglists (quote ([f z xs] [ctx f z xs])), :doc "Given an optional monadic context, a function that takes two non-monadic\n  arguments and returns a value inside the given monadic context, an initial\n  value, and a collection of values, perform a left-associative fold.\n\n      (require '[cats.context :as ctx]\n               '[cats.core :as m]\n               '[cats.monad.maybe :as maybe])\n\n      (defn m-div [x y]\n        (if (zero? y)\n          (maybe/nothing)\n          (maybe/just (/ x y))))\n\n      (m/foldm m-div 1 [1 2 3])\n      (m/foldm maybe/context m-div 1 [1 2 3])\n      ;; => #<Just 1/6>\n\n      (m/foldm maybe/context m-div 1 [1 0 3])\n      ;; => #<Nothing>\n\n      (foldm m-div 1 [])\n      ;; => Exception\n\n      (m/foldm maybe/context m-div 1 [])\n      (ctx/with-context maybe/context\n        (foldm m-div 1 []))\n      ;; => #<Just 1>\n  ", :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([f z xs] [ctx f z xs]), :arglists ([f z xs] [ctx f z xs]), :arglists-meta (nil nil)}}, :name cats.core/foldm, :variadic false, :file "resources/public/js/compiled/out/cats/core.cljc", :end-column 12, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([f z xs] [ctx f z xs]), :arglists ([f z xs] [ctx f z xs]), :arglists-meta (nil nil)}, :method-params ([f z xs] [ctx f z xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 700, :end-line 700, :max-fixed-arity 4, :fn-var true, :arglists ([f z xs] [ctx f z xs]), :doc "Given an optional monadic context, a function that takes two non-monadic\n  arguments and returns a value inside the given monadic context, an initial\n  value, and a collection of values, perform a left-associative fold.\n\n      (require '[cats.context :as ctx]\n               '[cats.core :as m]\n               '[cats.monad.maybe :as maybe])\n\n      (defn m-div [x y]\n        (if (zero? y)\n          (maybe/nothing)\n          (maybe/just (/ x y))))\n\n      (m/foldm m-div 1 [1 2 3])\n      (m/foldm maybe/context m-div 1 [1 2 3])\n      ;; => #<Just 1/6>\n\n      (m/foldm maybe/context m-div 1 [1 0 3])\n      ;; => #<Nothing>\n\n      (foldm m-div 1 [])\n      ;; => Exception\n\n      (m/foldm maybe/context m-div 1 [])\n      (ctx/with-context maybe/context\n        (foldm m-div 1 []))\n      ;; => #<Just 1>\n  "}, bindings->batches {:protocol-inline nil, :meta {:file "/home/emh/github/glsl-graph/resources/public/js/compiled/out/cats/core.cljc", :line 321, :column 8, :end-line 321, :end-column 25, :private true, :arglists (quote ([bindings]))}, :private true, :name cats.core/bindings->batches, :variadic false, :file "resources/public/js/compiled/out/cats/core.cljc", :end-column 25, :method-params ([bindings]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 321, :end-line 321, :max-fixed-arity 1, :fn-var true, :arglists (quote ([bindings]))}}, :require-macros {cats.core cats.core, ctx cats.context, cats.context cats.context}, :cljs.analyzer/constants {:seen #{& seq :renames :else single-arity? cats.core/fmap do mvs :syms avs cats.core/fapply :aps :seen cats.core/join not-empty cljs.core/fn var :arglists :body svs}, :order [seq svs mvs avs :else :body :syms :aps :seen :renames cats.core/fmap cljs.core/fn cats.core/fapply do cats.core/join :arglists & single-arity? var not-empty]}, :doc "Category Theory abstractions for Clojure"}