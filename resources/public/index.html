<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">    
    <link href="css/style.css" rel="stylesheet" type="text/css">
    <script src="js/compiled/deps.js" type="text/javascript"></script>
    <script src="js/compiled/glsl_graph.js" type="text/javascript"></script>
  </head>
  <body>
    <div class="whole-height" id="graphVisualization"></div>

    <script type="x-shader/x-vertex" id="pass-through-vs">
      void main() {
        gl_Position = vec4( position, 1.0 );
      }
    </script>

    <script type="x-shader/x-fragment" id="pass-through-fs">
      uniform vec2 u_resolution;
      uniform sampler2D u_pass_texture;

      void main() {
        vec2 uv = gl_FragCoord.xy / u_resolution.xy;
        gl_FragColor = texture2D(u_pass_texture, uv);
      }
    </script>

    <script type="x-shader/x-fragment" id="position-fs">
#ifdef GL_ES
      precision highp float;
#endif
uniform sampler2D u_texture_positions;
uniform sampler2D u_texture_velocities;
uniform sampler2D u_texture_edges;
uniform vec2 u_resolution;
uniform float u_node_count;
uniform float u_min_dist;
uniform float u_dist_reduction;
uniform float u_speed_reduction;
uniform float u_iteration;
uniform float u_time;
uniform float u_time_old;
uniform float u_time_delta;
uniform float u_spring_coefficient;
uniform float u_spring_length;
// why u_time_delta != u_time - u_time_old ?
// #define TIMEDELTA ((u_time - u_time_old) * 60.0 / 1000.0)
// #define TIMEDELTA ((u_time - u_time_old) * 60.0 / 1000.0)
#define TIMEDELTA 1.0
//u_time_delta * 180.0
#define SQNODEF float(SQNODE)
#define SQEDGEF float(SQEDGE)
#define NODECOUNTF float(NODECOUNT)
#define EDGECOUNTF float(EDGECOUNT)
#define ITER 20.0
#define EPS 1.0e-7
#define SCALE 1000.0

vec2 swap(vec2 v) {
  return v.xy;
}

vec2 nodeIndexToPos(float i) {
  vec2 v = vec2(mod(i, SQNODEF), floor(i / SQNODEF));
  v = swap(v);
  vec2 nodePos = vec2(v.x / SQNODEF, v.y / SQNODEF);
  return nodePos;
}

vec2 edgeIndexToPos(float i) {
  vec2 v = vec2(mod(i, SQEDGEF), floor(i / SQEDGEF));
  v = swap(v);
  vec2 edgePos = vec2(v.x / SQEDGEF, v.y / SQEDGEF);
  return edgePos;
}

vec3 project(vec3 diff) {
  if (USE3D) {
    return diff;
  } else {
    // 2D
    return vec3(diff.x, 0.0, diff.z);
    //return vec3(diff.x, diff.z, 0.0);
  }
}

vec3 gaussSeidel(float alpha, vec3 diff, float degree, float other_degree) {
  // gauss-seidel relaxation for links, from d3
  float x = diff.x;
  float y = diff.y;
  float z = diff.z;
  float strength = 0.005;
  //float dist = 20.0;
  float dist = 50.0;
  vec3 delta = vec3(0.0);
  float l = (x * x) + (y * y) + (z * z);
  if (l > 0.0) {
    l = alpha * strength * ((l = sqrt(l)) - dist) / l;
    x *= l;
    y *= l;
    z *= l;
    float s_weight = other_degree;
    float t_weight = degree;
    float k = s_weight / (t_weight + s_weight);
    delta.x -= x * k;
    delta.y -= y * k;
    delta.z -= z * k;
  }
  return delta;
}

float rand(vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

float attract(float d) {
  return 1.0e-7 * d;
  // return 1.0e-1 * log(d);
  // return d * d;
}

vec3 scalePos(vec3 pos) {
  return (pos * 2.0 - 1.0) * SCALE;
}

vec3 unscalePos(vec3 pos) {
  return ((pos / SCALE) + 1.0) / 2.0;
}

// POSITION SHADER
vec3 calcSpring(float alpha, float degree, vec3 planetPos, float planetIndex) {
  vec3 delta = vec3(0.0);

  vec4 tpos = texture2D(u_texture_positions, nodeIndexToPos(planetIndex));
  float other_degree = tpos.w * EDGECOUNTF;
  vec3 planet2Pos = scalePos(tpos.xyz);
  vec3 diff = planet2Pos - scalePos(planetPos);
  diff = project(diff);
  //diff = normalize(diff);

  // forces
  float dist = length(diff);
  float distSquare = dist * dist;
  float k = other_degree / (other_degree + degree);

  //delta += gaussSeidel(alpha, diff, degree, other_degree);

  // spring force
  float SPRING_LENGTH = u_spring_length;
  float SPRING_COEFF = u_spring_coefficient;
  /*if (dist < 0.1) {
    vec2 co = vec2(ITER, u_time);
    vec2 co2 = vec2(ITER, u_time) + planetPos.xy;
    vec2 co3 = vec2(u_time * 69.0, ITER) + planetPos.xy;
    diff = vec3(rand(co), rand(co2), rand(co3));
    diff = project(diff);
  }*/
  // float s = sign(dist - SPRING_LENGTH);
  if (dist < SPRING_LENGTH) {
    float X = attract(SPRING_LENGTH - dist);
    float F_spring = SPRING_COEFF * X;
    delta += -diff * F_spring * k;
  } else if (dist > SPRING_LENGTH) {
    float X = attract(dist - SPRING_LENGTH);
    float F_spring = SPRING_COEFF * X;
    delta += diff * F_spring * k;
  }

  // Coloumb force
  float ke = 8.987 * 10.0e9;
  ke /= 10.0e14;
  vec3 F_C = -ke * diff * k;
  // delta += F_C;

  // gravity
  // float F_gravity = -1.2 / (u_min_dist + distSquare) / u_dist_reduction / 10000.0;
  //float F_gravity = (-1.2 / distSquare / u_dist_reduction) * k;
  //delta += diff * F_gravity;

  return delta;
}

vec3 calcGravity(float alpha, float degree, vec3 planetPos) {
  vec3 diff = -planetPos;
  vec3 delta = vec3(0.0);
  float gravity = 0.01;
  float k = alpha * gravity;
  delta += diff * k;
  return delta;
}

// POSITION SHADER
void main( void ) {
  vec2 p = gl_FragCoord.xy / u_resolution;

  vec4 tpos = texture2D(u_texture_positions, p);
  vec4 tvel = texture2D(u_texture_velocities, p);

  vec3 planetPos = project(tpos.xyz);
  //planetPos = planetPos * 2.0 - 1.0;
  planetPos = scalePos(planetPos);

  float degree = tpos.w * EDGECOUNTF;
  float startEdge = tvel.w * EDGECOUNTF;
  float endEdge = startEdge + degree;
  float alpha = max(pow(0.999, u_iteration), 0.0);

  vec3 delta = vec3(0.0);

  float oldEdge = -1.0;
  vec4 oldFourEdges = vec4(0.0);
  for (float i = 0.0; i < ITER; i += 1.0) {
    float edgeIndex = startEdge + mod(u_iteration * ITER + i, degree);
    float edge = floor(edgeIndex / 4.0);
    int off = int(floor(mod(edgeIndex, 4.0)));
    vec4 fourEdges;
    if (edge == oldEdge) {
      fourEdges = oldFourEdges;
    } else {
      fourEdges = texture2D(u_texture_edges, edgeIndexToPos(edge));
      oldFourEdges = fourEdges;
      oldEdge = edge;
    }
    float planetIndex;
    if (off == 0) {
      planetIndex = fourEdges[0];
    } else if (off == 1) {
      planetIndex = fourEdges[1];
    } else if (off == 2) {
      planetIndex = fourEdges[2];
    } else if (off == 3) {
      planetIndex = fourEdges[3];
    } else {
      planetIndex = fourEdges[0];
    }
    planetIndex *= NODECOUNTF;
    // delta += calcSpring(alpha, degree, planetPos, planetIndex);
  }
  /*for (float i = 0.0; i < NODECOUNTF; i += 1.0) {
    delta -= calcSpring(alpha, degree, planetPos, i);
  }*/
  //delta += calcGravity(1.0, degree, planetPos);
  const float maxSpeed = 0.1 * SCALE;
  //delta = clamp(delta, vec3(-maxSpeed), vec3(maxSpeed));

  vec3 newPosition = planetPos;
  newPosition += TIMEDELTA * delta * alpha / pow(abs(u_speed_reduction), 1.5);

  vec3 planetVelocity = tvel.xyz;
  planetVelocity = planetVelocity * 2.0 - 1.0;
  planetVelocity /= u_speed_reduction;
  newPosition += TIMEDELTA * planetVelocity * SCALE;

  const float size = 1.0;
  //newPosition = clamp(newPosition, -size, size);
  // newPosition = (newPosition + 1.0) / 2.0;
  newPosition = unscalePos(newPosition);

  gl_FragColor = vec4(newPosition, tpos.w);
}
    </script>

    <script type="x-shader/x-fragment" id="velocity-fs">
#ifdef GL_ES
      precision highp float;
#endif
uniform sampler2D u_texture_positions;
uniform sampler2D u_texture_velocities;
uniform sampler2D u_texture_edges;
uniform vec2 u_resolution;
uniform float u_node_count;
uniform float u_min_dist;
uniform float u_dist_reduction;
uniform float u_iteration;
uniform float u_time;
uniform float u_time_old;
uniform float u_time_delta;
uniform float u_spring_length;
uniform float u_spring_coefficient;
#define SQNODEF float(SQNODE)
#define SQEDGEF float(SQEDGE)
#define NODECOUNTF float(NODECOUNT)
#define EDGECOUNTF float(EDGECOUNT)
#define ITER 20.0
#define SCALE 1000.0

vec2 swap(vec2 v) {
  return v.xy;
}

vec2 nodeIndexToPos(float i) {
  vec2 v = vec2(mod(i, SQNODEF), floor(i / SQNODEF));
  v = swap(v);
  vec2 nodePos = vec2(v.x / SQNODEF, v.y / SQNODEF);
  return nodePos;
}

vec2 edgeIndexToPos(float i) {
  vec2 v = vec2(mod(i, SQEDGEF), floor(i / SQEDGEF));
  v = swap(v);
  vec2 edgePos = vec2(v.x / SQEDGEF, v.y / SQEDGEF);
  return edgePos;
}

vec3 project(vec3 diff) {
  if (USE3D) {
    return diff;
  } else {
    // 2D
    //return vec3(diff.xy, 0.0);
    return vec3(diff.x, 0.0, diff.z);
  }
}

float attract(float d) {
  return d;
  // return log(d);
  // return d * d;
}

float rand(vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 scalePos(vec3 pos) {
  return (pos * 2.0 - 1.0) * SCALE;
}

vec3 unscalePos(vec3 pos) {
  return ((pos / SCALE) + 1.0) / 2.0;
}

// VELOCITY SHADER
vec3 calcSpring(float degree, vec3 planetPos, float planetIndex) {
  vec3 delta = vec3(0.0);

  vec4 tpos = texture2D(u_texture_positions, nodeIndexToPos(planetIndex));
  float other_degree = tpos.w * EDGECOUNTF;
  vec3 planet2Pos = scalePos(tpos.xyz);
  vec3 diff = planet2Pos - planetPos;
  diff = project(diff);

  // forces
  float dist = length(diff);
  float distSquare = dist * dist;
  // float k = other_degree / (other_degree + degree);
  float k = 1.0;

  /*if (dist < 0.1) {
    vec2 co = vec2(u_time*5.0, u_time*3.0) + planetIndex;
    vec2 co2 = vec2(u_time*13.0, u_time*17.0) + planetIndex;
    vec2 co3 = vec2(u_time*29.0, u_time*53.0) + planetIndex;
    diff = vec3(rand(co), rand(co2), rand(co3));
    diff = project(diff);
    dist = length(diff);
    distSquare = dist * dist;
  }*/

  // spring force
  //diff = normalize(diff);
  float SPRING_LENGTH = u_spring_length;
  float SPRING_COEFF = u_spring_coefficient;
  float k1 = 1.0;
  if (dist < SPRING_LENGTH) {
    float X = attract(k1 * (SPRING_LENGTH - dist));
    float F_spring = SPRING_COEFF * X;
    delta += -diff * F_spring * k;
  } else if (dist > SPRING_LENGTH) {
    float X = attract(k1 * (dist - SPRING_LENGTH));
    float F_spring = SPRING_COEFF * X;
    delta += diff * F_spring * k;
  }
  //delta = clamp(delta, -1.0, 1.0);

  // Coloumb force
  float ke = 0.001;
  vec3 F_C = -ke * diff;
  delta += F_C;

  // gravity
  // float F_gravity = -1.2 / (u_min_dist + distSquare) / u_dist_reduction / 10000.0;
  //float F_gravity = (-1.2 / distSquare / u_dist_reduction) * k;
  //delta += diff * F_gravity;

  return delta;
}

// VELOCITY SHADER
vec3 calcGravity(float degree, vec3 planetPos, float planetIndex) {
  vec3 delta = vec3(0.0);

  vec4 tpos = texture2D(u_texture_positions, nodeIndexToPos(planetIndex));
  float other_degree = tpos.w * EDGECOUNTF;
  vec3 planet2Pos = scalePos(tpos.xyz);
  vec3 diff = planet2Pos - planetPos;
  diff = project(diff);

  // forces
  float dist = length(diff);
  float distSquare = dist * dist;
  //float k = other_degree / (other_degree + degree);
  float k = 1.0 - other_degree / (other_degree + degree);

  /*if (dist < 0.1) {
    // TODO: not working
    vec2 co = vec2(u_time/5.0, u_time/3.0) + planetIndex;
    vec2 co2 = vec2(u_time/13.0, u_time/17.0) + planetIndex;
    vec2 co3 = vec2(u_time/29.0, u_time/53.0) + planetIndex;
    diff = vec3(rand(co), rand(co2), rand(co3));
    diff = project(diff);
    dist = length(diff);
    distSquare = dist * dist;
  }*/

  // gravity
  const float G = -1.2 * 100.0;
  //float F_gravity = G / (u_min_dist + distSquare) / u_dist_reduction;
  float F_gravity = G / (1.0 + distSquare) / u_dist_reduction;
  //delta += normalize(diff) * F_gravity;
  delta += diff * F_gravity * k;

  // Coloumb force
  // delta -= 0.001 * diff;

  // center
  if (
    planetPos.x > SCALE / 10.0 || 
    planetPos.x < -SCALE / 10.0 || 
    planetPos.y > SCALE / 10.0 ||
    planetPos.y < -SCALE / 10.0
    ) {
    vec3 diff2 = vec3(0.5) - planetPos;
    diff2 = project(diff2);
    distSquare = length(diff2);
    distSquare *= distSquare;
    F_gravity = -G * 10.0 / distSquare / u_dist_reduction;
    //delta += diff2 * F_gravity;
  }

  return delta;
}

// VELOCITY SHADER
void main( void ) {
  vec2 p = gl_FragCoord.xy / u_resolution;

  vec4 tpos = texture2D(u_texture_positions, p);
  vec4 tvel = texture2D(u_texture_velocities, p);
  vec3 planetPos = scalePos(tpos.xyz);
  vec3 planetVelocity = tvel.xyz * 2.0 - 1.0;

  float degree = tpos.w * EDGECOUNTF;
  float startEdge = tvel.w * EDGECOUNTF;
  float endEdge = startEdge + degree;
  float alpha = max(pow(0.999, u_iteration), 0.0);

  vec3 delta = vec3(0.0);

  float oldEdge = -1.0;
  vec4 oldFourEdges = vec4(0.0);
  for (float i = 0.0; i < ITER; i += 1.0) {
    float edgeIndex = startEdge + mod(u_iteration * ITER + i, startEdge - endEdge);
    float edge = floor(edgeIndex / 4.0);
    int off = int(floor(mod(edgeIndex, 4.0)));
    vec4 fourEdges;
    if (edge == oldEdge) {
      fourEdges = oldFourEdges;
    } else {
      fourEdges = texture2D(u_texture_edges, edgeIndexToPos(edge));
      oldFourEdges = fourEdges;
      oldEdge = edge;
    }
    float planetIndex; // = fourEdges[0];
    if (off == 0) {
      planetIndex = fourEdges[0];
    } else if (off == 1) {
      planetIndex = fourEdges[1];
    } else if (off == 2) {
      planetIndex = fourEdges[2];
    } else if (off == 3) {
      planetIndex = fourEdges[3];
    }
    planetIndex *= NODECOUNTF;
    delta += calcSpring(degree, planetPos, planetIndex);
    //delta -= calcGravity(degree, planetPos, planetIndex);
  }
  for (float i = 0.0; i < NODECOUNTF; i += 1.0) {
    delta += calcGravity(degree, planetPos, i);
  }
  delta /= pow(SCALE, 1.0);
  float clampSize = 1.0;
  delta = clamp(delta, vec3(-clampSize), vec3(clampSize));
  planetVelocity = clamp(planetVelocity, vec3(-clampSize), vec3(clampSize));
  
  planetVelocity = (planetVelocity * 0.9 + delta * alpha);
  planetVelocity = (planetVelocity + 1.0) / 2.0;
  

  gl_FragColor = vec4(planetVelocity, tvel.w);
}
  </script>

  <script type="x-shader/x-vertex" id="screen-vs">
#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D u_texture_positions;
attribute vec3 a_color;
attribute vec2 a_displacement_index;
varying vec3 v_color;

void main() {
  vec3 planetPos = texture2D(u_texture_positions, a_displacement_index).xyz;
  planetPos = (planetPos * 2.0) - 1.0;
  // planetPos += position.xyz;
  v_color = a_color;

  gl_PointSize = 5.0;

  gl_Position = projectionMatrix * modelViewMatrix * vec4(planetPos, 1.0);
}

  </script>

  <script type="x-shader/x-fragment" id="screen-fs">
#ifdef GL_ES
precision highp float;
#endif

varying vec3 v_color;

void main()
{
  vec2 mid = vec2(0.5, 0.5);
  float d = length(gl_PointCoord - mid);
  float r = 0.1 / pow(d, 2.0);
  float alpha = 0.0;
  const float outer = 0.5;
  if (d < outer) {
    alpha = 1.0;
  }
  vec3 rgb = v_color;
  gl_FragColor = vec4(rgb, alpha);
}
  </script>

  <script type="x-shader/x-vertex" id="lines-vs">
#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D u_texture_positions;
//attribute vec3 a_color;
attribute vec2 a_displacement_index;
//varying vec3 v_color;

void main() {
  vec3 planetPos = texture2D(u_texture_positions, a_displacement_index).xyz;
  planetPos = (planetPos * 2.0) - 1.0 + position;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(planetPos, 1.0);
}
  </script>

  <script type="x-shader/x-fragment" id="lines-fs">
#ifdef GL_ES
precision highp float;
#endif

void main()
{
  gl_FragColor = vec4(0.5, 0.5, 0.5, 1.0);
}
  </script>

  </body>
</html>
